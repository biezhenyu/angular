{"version":3,"sources":["webpack:///./~/better-scroll/dist/bscroll.js?c627","webpack:///./~/better-scroll/dist/bscroll.js","webpack:///./~/script-loader/addScript.js"],"names":[],"mappings":"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","file":"scripts.bundle.js","sourcesContent":["require(\"!!/Users/zhenyu/Desktop/angular/mobile/node_modules/script-loader/addScript.js\")(require(\"!!/Users/zhenyu/Desktop/angular/mobile/node_modules/raw-loader/index.js!/Users/zhenyu/Desktop/angular/mobile/node_modules/better-scroll/dist/bscroll.js\"))\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/script-loader!./~/better-scroll/dist/bscroll.js\n// module id = 390\n// module chunks = 3","module.exports = \"/*!\\n * better-normal-scroll v1.3.1\\n * (c) 2016-2017 ustbhuangyi\\n * Released under the MIT License.\\n */\\n(function (global, factory) {\\n\\ttypeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :\\n\\ttypeof define === 'function' && define.amd ? define(factory) :\\n\\t(global.BScroll = factory());\\n}(this, (function () { 'use strict';\\n\\nvar slicedToArray = function () {\\n  function sliceIterator(arr, i) {\\n    var _arr = [];\\n    var _n = true;\\n    var _d = false;\\n    var _e = undefined;\\n\\n    try {\\n      for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\\n        _arr.push(_s.value);\\n\\n        if (i && _arr.length === i) break;\\n      }\\n    } catch (err) {\\n      _d = true;\\n      _e = err;\\n    } finally {\\n      try {\\n        if (!_n && _i[\\\"return\\\"]) _i[\\\"return\\\"]();\\n      } finally {\\n        if (_d) throw _e;\\n      }\\n    }\\n\\n    return _arr;\\n  }\\n\\n  return function (arr, i) {\\n    if (Array.isArray(arr)) {\\n      return arr;\\n    } else if (Symbol.iterator in Object(arr)) {\\n      return sliceIterator(arr, i);\\n    } else {\\n      throw new TypeError(\\\"Invalid attempt to destructure non-iterable instance\\\");\\n    }\\n  };\\n}();\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\nvar toConsumableArray = function (arr) {\\n  if (Array.isArray(arr)) {\\n    for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];\\n\\n    return arr2;\\n  } else {\\n    return Array.from(arr);\\n  }\\n};\\n\\nfunction eventMixin(BScroll) {\\n  BScroll.prototype.on = function (type, fn) {\\n    var context = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this;\\n\\n    if (!this._events[type]) {\\n      this._events[type] = [];\\n    }\\n\\n    this._events[type].push([fn, context]);\\n  };\\n\\n  BScroll.prototype.once = function (type, fn) {\\n    var context = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this;\\n\\n    var fired = false;\\n\\n    function magic() {\\n      this.off(type, magic);\\n\\n      if (!fired) {\\n        fired = true;\\n        fn.apply(context, arguments);\\n      }\\n    }\\n\\n    this.on(type, magic);\\n  };\\n\\n  BScroll.prototype.off = function (type, fn) {\\n    var _events = this._events[type];\\n    if (!_events) {\\n      return;\\n    }\\n\\n    var count = _events.length;\\n    while (count--) {\\n      if (_events[count][0] === fn) {\\n        _events[count][0] = undefined;\\n      }\\n    }\\n  };\\n\\n  BScroll.prototype.trigger = function (type) {\\n    var events = this._events[type];\\n    if (!events) {\\n      return;\\n    }\\n\\n    var len = events.length;\\n    var eventsCopy = [].concat(toConsumableArray(events));\\n    for (var i = 0; i < len; i++) {\\n      var event = eventsCopy[i];\\n\\n      var _event = slicedToArray(event, 2),\\n          fn = _event[0],\\n          context = _event[1];\\n\\n      if (fn) {\\n        fn.apply(context, [].slice.call(arguments, 1));\\n      }\\n    }\\n  };\\n}\\n\\nvar elementStyle = document.createElement('div').style;\\n\\nvar vendor = function () {\\n  var transformNames = {\\n    webkit: 'webkitTransform',\\n    Moz: 'MozTransform',\\n    O: 'OTransform',\\n    ms: 'msTransform',\\n    standard: 'transform'\\n  };\\n\\n  for (var key in transformNames) {\\n    if (elementStyle[transformNames[key]] !== undefined) {\\n      return key;\\n    }\\n  }\\n\\n  return false;\\n}();\\n\\nfunction prefixStyle(style) {\\n  if (vendor === false) {\\n    return false;\\n  }\\n\\n  if (vendor === 'standard') {\\n    return style;\\n  }\\n\\n  return vendor + style.charAt(0).toUpperCase() + style.substr(1);\\n}\\n\\nfunction addEvent(el, type, fn, capture) {\\n  el.addEventListener(type, fn, { passive: false, capture: !!capture });\\n}\\n\\nfunction removeEvent(el, type, fn, capture) {\\n  el.removeEventListener(type, fn, { passive: false, capture: !!capture });\\n}\\n\\nfunction offset(el) {\\n  var left = 0;\\n  var top = 0;\\n\\n  while (el) {\\n    left -= el.offsetLeft;\\n    top -= el.offsetTop;\\n    el = el.offsetParent;\\n  }\\n\\n  return {\\n    left: left,\\n    top: top\\n  };\\n}\\n\\nvar transform = prefixStyle('transform');\\n\\nvar hasPerspective = prefixStyle('perspective') in elementStyle;\\nvar hasTouch = 'ontouchstart' in window;\\nvar hasTransform = transform !== false;\\nvar hasTransition = prefixStyle('transition') in elementStyle;\\n\\nvar style = {\\n  transform: transform,\\n  transitionTimingFunction: prefixStyle('transitionTimingFunction'),\\n  transitionDuration: prefixStyle('transitionDuration'),\\n  transitionDelay: prefixStyle('transitionDelay'),\\n  transformOrigin: prefixStyle('transformOrigin'),\\n  transitionEnd: prefixStyle('transitionEnd')\\n};\\n\\nvar TOUCH_EVENT = 1;\\nvar MOUSE_EVENT = 2;\\n\\nvar eventType = {\\n  touchstart: TOUCH_EVENT,\\n  touchmove: TOUCH_EVENT,\\n  touchend: TOUCH_EVENT,\\n\\n  mousedown: MOUSE_EVENT,\\n  mousemove: MOUSE_EVENT,\\n  mouseup: MOUSE_EVENT\\n};\\n\\nfunction getRect(el) {\\n  if (el instanceof window.SVGElement) {\\n    var rect = el.getBoundingClientRect();\\n    return {\\n      top: rect.top,\\n      left: rect.left,\\n      width: rect.width,\\n      height: rect.height\\n    };\\n  } else {\\n    return {\\n      top: el.offsetTop,\\n      left: el.offsetLeft,\\n      width: el.offsetWidth,\\n      height: el.offsetHeight\\n    };\\n  }\\n}\\n\\nfunction preventDefaultException(el, exceptions) {\\n  for (var i in exceptions) {\\n    if (exceptions[i].test(el[i])) {\\n      return true;\\n    }\\n  }\\n  return false;\\n}\\n\\nfunction tap(e, eventName) {\\n  var ev = document.createEvent('Event');\\n  ev.initEvent(eventName, true, true);\\n  ev.pageX = e.pageX;\\n  ev.pageY = e.pageY;\\n  e.target.dispatchEvent(ev);\\n}\\n\\nfunction click(e) {\\n  var target = e.target;\\n\\n  if (!/(SELECT|INPUT|TEXTAREA)/i.test(target.tagName)) {\\n    var ev = document.createEvent(window.MouseEvent ? 'MouseEvents' : 'Event');\\n    // cancelable 设置为 false 是为了解决和 fastclick 冲突问题\\n    ev.initEvent('click', true, false);\\n    ev._constructed = true;\\n    target.dispatchEvent(ev);\\n  }\\n}\\n\\nfunction prepend(el, target) {\\n  if (target.firstChild) {\\n    before(el, target.firstChild);\\n  } else {\\n    target.appendChild(el);\\n  }\\n}\\n\\nfunction before(el, target) {\\n  target.parentNode.insertBefore(el, target);\\n}\\n\\nfunction getNow() {\\n  return window.performance && window.performance.now ? window.performance.now() + window.performance.timing.navigationStart : +new Date();\\n}\\n\\nfunction extend(target) {\\n  for (var _len = arguments.length, rest = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\\n    rest[_key - 1] = arguments[_key];\\n  }\\n\\n  for (var i = 0; i < rest.length; i++) {\\n    var source = rest[i];\\n    for (var key in source) {\\n      target[key] = source[key];\\n    }\\n  }\\n  return target;\\n}\\n\\nvar DEFAULT_OPTIONS = {\\n  startX: 0,\\n  startY: 0,\\n  scrollX: false,\\n  scrollY: true,\\n  freeScroll: false,\\n  directionLockThreshold: 5,\\n  eventPassthrough: '',\\n  click: false,\\n  tap: false,\\n  bounce: true,\\n  bounceTime: 700,\\n  momentum: true,\\n  momentumLimitTime: 300,\\n  momentumLimitDistance: 15,\\n  swipeTime: 2500,\\n  swipeBounceTime: 500,\\n  deceleration: 0.001,\\n  flickLimitTime: 200,\\n  flickLimitDistance: 100,\\n  resizePolling: 60,\\n  probeType: 0,\\n  preventDefault: true,\\n  preventDefaultException: {\\n    tagName: /^(INPUT|TEXTAREA|BUTTON|SELECT)$/\\n  },\\n  HWCompositing: true,\\n  useTransition: true,\\n  useTransform: true,\\n  bindToWrapper: false,\\n  disableMouse: hasTouch,\\n  disableTouch: !hasTouch,\\n  /**\\n   * for picker\\n   * wheel: {\\n   *   selectedIndex: 0,\\n   *   rotate: 25,\\n   *   adjustTime: 400\\n   * }\\n   */\\n  wheel: false,\\n  /**\\n   * for slide\\n   * snap: {\\n   *   loop: false,\\n   *   el: domEl,\\n   *   threshold: 0.1,\\n   *   stepX: 100,\\n   *   stepY: 100,\\n   *   listenFlick: true\\n   * }\\n   */\\n  snap: false,\\n  /**\\n   * for scrollbar\\n   * scrollbar: {\\n   *   fade: true\\n   * }\\n   */\\n  scrollbar: false,\\n  /**\\n   * for pull down and refresh\\n   * pullDownRefresh: {\\n   *   threshold: 50,\\n   *   stop: 20\\n   * }\\n   */\\n  pullDownRefresh: false,\\n  /**\\n   * for pull up and load\\n   * pullUpLoad: {\\n   *   threshold: 50\\n   * }\\n   */\\n  pullUpLoad: false\\n};\\n\\nfunction initMixin(BScroll) {\\n  BScroll.prototype._init = function (el, options) {\\n    this._handleOptions(options);\\n\\n    // init private custom events\\n    this._events = {};\\n\\n    this.x = 0;\\n    this.y = 0;\\n    this.directionX = 0;\\n    this.directionY = 0;\\n\\n    this._addDOMEvents();\\n\\n    this._initExtFeatures();\\n\\n    this.refresh();\\n\\n    if (!this.options.snap) {\\n      this.scrollTo(this.options.startX, this.options.startY);\\n    }\\n\\n    this.enable();\\n  };\\n\\n  BScroll.prototype._handleOptions = function (options) {\\n    this.options = extend({}, DEFAULT_OPTIONS, options);\\n\\n    this.translateZ = this.options.HWCompositing && hasPerspective ? ' translateZ(0)' : '';\\n\\n    this.options.useTransition = this.options.useTransition && hasTransition;\\n    this.options.useTransform = this.options.useTransform && hasTransform;\\n\\n    this.options.preventDefault = !this.options.eventPassthrough && this.options.preventDefault;\\n\\n    // If you want eventPassthrough I have to lock one of the axes\\n    this.options.scrollX = this.options.eventPassthrough === 'horizontal' ? false : this.options.scrollX;\\n    this.options.scrollY = this.options.eventPassthrough === 'vertical' ? false : this.options.scrollY;\\n\\n    // With eventPassthrough we also need lockDirection mechanism\\n    this.options.freeScroll = this.options.freeScroll && !this.options.eventPassthrough;\\n    this.options.directionLockThreshold = this.options.eventPassthrough ? 0 : this.options.directionLockThreshold;\\n\\n    if (this.options.tap === true) {\\n      this.options.tap = 'tap';\\n    }\\n  };\\n\\n  BScroll.prototype._addDOMEvents = function () {\\n    var eventOperation = addEvent;\\n    this._handleDOMEvents(eventOperation);\\n  };\\n\\n  BScroll.prototype._removeDOMEvents = function () {\\n    var eventOperation = removeEvent;\\n    this._handleDOMEvents(eventOperation);\\n  };\\n\\n  BScroll.prototype._handleDOMEvents = function (eventOperation) {\\n    var target = this.options.bindToWrapper ? this.wrapper : window;\\n    eventOperation(window, 'orientationchange', this);\\n    eventOperation(window, 'resize', this);\\n\\n    if (this.options.click) {\\n      eventOperation(this.wrapper, 'click', this, true);\\n    }\\n\\n    if (!this.options.disableMouse) {\\n      eventOperation(this.wrapper, 'mousedown', this);\\n      eventOperation(target, 'mousemove', this);\\n      eventOperation(target, 'mousecancel', this);\\n      eventOperation(target, 'mouseup', this);\\n    }\\n\\n    if (hasTouch && !this.options.disableTouch) {\\n      eventOperation(this.wrapper, 'touchstart', this);\\n      eventOperation(target, 'touchmove', this);\\n      eventOperation(target, 'touchcancel', this);\\n      eventOperation(target, 'touchend', this);\\n    }\\n\\n    eventOperation(this.scroller, style.transitionEnd, this);\\n  };\\n\\n  BScroll.prototype._initExtFeatures = function () {\\n    if (this.options.snap) {\\n      this._initSnap();\\n    }\\n    if (this.options.scrollbar) {\\n      this._initScrollbar();\\n    }\\n    if (this.options.pullUpLoad) {\\n      this._initPullUp();\\n    }\\n    if (this.options.pullDownRefresh) {\\n      this._initPullDown();\\n    }\\n  };\\n\\n  BScroll.prototype.handleEvent = function (e) {\\n    switch (e.type) {\\n      case 'touchstart':\\n      case 'mousedown':\\n        this._start(e);\\n        break;\\n      case 'touchmove':\\n      case 'mousemove':\\n        this._move(e);\\n        break;\\n      case 'touchend':\\n      case 'mouseup':\\n      case 'touchcancel':\\n      case 'mousecancel':\\n        this._end(e);\\n        break;\\n      case 'orientationchange':\\n      case 'resize':\\n        this._resize();\\n        break;\\n      case 'transitionend':\\n      case 'webkitTransitionEnd':\\n      case 'oTransitionEnd':\\n      case 'MSTransitionEnd':\\n        this._transitionEnd(e);\\n        break;\\n      case 'click':\\n        if (this.enabled && !e._constructed) {\\n          if (!preventDefaultException(e.target, this.options.preventDefaultException)) {\\n            e.preventDefault();\\n          }\\n          e.stopPropagation();\\n        }\\n        break;\\n    }\\n  };\\n\\n  BScroll.prototype.refresh = function () {\\n    var wrapperRect = getRect(this.wrapper);\\n    this.wrapperWidth = wrapperRect.width;\\n    this.wrapperHeight = wrapperRect.height;\\n\\n    var scrollerRect = getRect(this.scroller);\\n    this.scrollerWidth = scrollerRect.width;\\n    this.scrollerHeight = scrollerRect.height;\\n\\n    var wheel = this.options.wheel;\\n    if (wheel) {\\n      this.items = this.scroller.children;\\n      this.options.itemHeight = this.itemHeight = this.items.length ? this.scrollerHeight / this.items.length : 0;\\n      if (this.selectedIndex === undefined) {\\n        this.selectedIndex = wheel.selectedIndex;\\n      }\\n      this.options.startY = -this.selectedIndex * this.itemHeight;\\n      this.maxScrollX = 0;\\n      this.maxScrollY = -this.itemHeight * (this.items.length - 1);\\n    } else {\\n      this.maxScrollX = this.wrapperWidth - this.scrollerWidth;\\n      this.maxScrollY = this.wrapperHeight - this.scrollerHeight;\\n    }\\n\\n    this.hasHorizontalScroll = this.options.scrollX && this.maxScrollX < 0;\\n    this.hasVerticalScroll = this.options.scrollY && this.maxScrollY < 0;\\n\\n    if (!this.hasHorizontalScroll) {\\n      this.maxScrollX = 0;\\n      this.scrollerWidth = this.wrapperWidth;\\n    }\\n\\n    if (!this.hasVerticalScroll) {\\n      this.maxScrollY = 0;\\n      this.scrollerHeight = this.wrapperHeight;\\n    }\\n\\n    this.endTime = 0;\\n    this.directionX = 0;\\n    this.directionY = 0;\\n    this.wrapperOffset = offset(this.wrapper);\\n\\n    this.trigger('refresh');\\n\\n    this.resetPosition();\\n  };\\n\\n  BScroll.prototype.enable = function () {\\n    this.enabled = true;\\n  };\\n\\n  BScroll.prototype.disable = function () {\\n    this.enabled = false;\\n  };\\n}\\n\\nvar ease = {\\n\\t// easeOutQuint\\n\\tswipe: {\\n\\t\\tstyle: 'cubic-bezier(0.23, 1, 0.32, 1)',\\n\\t\\tfn: function fn(t) {\\n\\t\\t\\treturn 1 + --t * t * t * t * t;\\n\\t\\t}\\n\\t},\\n\\t// easeOutQuard\\n\\tswipeBounce: {\\n\\t\\tstyle: 'cubic-bezier(0.25, 0.46, 0.45, 0.94)',\\n\\t\\tfn: function fn(t) {\\n\\t\\t\\treturn t * (2 - t);\\n\\t\\t}\\n\\t},\\n\\t// easeOutQuart\\n\\tbounce: {\\n\\t\\tstyle: 'cubic-bezier(0.165, 0.84, 0.44, 1)',\\n\\t\\tfn: function fn(t) {\\n\\t\\t\\treturn 1 - --t * t * t * t;\\n\\t\\t}\\n\\t}\\n};\\n\\nfunction momentum(current, start, time, lowerMargin, wrapperSize, options) {\\n  var distance = current - start;\\n  var speed = Math.abs(distance) / time;\\n\\n  var deceleration = options.deceleration,\\n      itemHeight = options.itemHeight,\\n      swipeBounceTime = options.swipeBounceTime,\\n      wheel = options.wheel,\\n      swipeTime = options.swipeTime;\\n\\n  var duration = swipeTime;\\n  var rate = wheel ? 4 : 15;\\n\\n  var destination = current + speed / deceleration * (distance < 0 ? -1 : 1);\\n\\n  if (wheel && itemHeight) {\\n    destination = Math.round(destination / itemHeight) * itemHeight;\\n  }\\n\\n  if (destination < lowerMargin) {\\n    destination = wrapperSize ? lowerMargin - wrapperSize / rate * speed : lowerMargin;\\n    duration = swipeBounceTime;\\n  } else if (destination > 0) {\\n    destination = wrapperSize ? wrapperSize / rate * speed : 0;\\n    duration = swipeBounceTime;\\n  }\\n\\n  return {\\n    destination: Math.round(destination),\\n    duration: duration\\n  };\\n}\\n\\nvar DEFAULT_INTERVAL = 100 / 60;\\n\\nvar requestAnimationFrame = function () {\\n  return window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame ||\\n  // if all else fails, use setTimeout\\n  function (callback) {\\n    return window.setTimeout(callback, (callback.interval || DEFAULT_INTERVAL) / 2); // make interval as precise as possible.\\n  };\\n}();\\n\\nvar cancelAnimationFrame = function () {\\n  return window.cancelAnimationFrame || window.webkitCancelAnimationFrame || window.mozCancelAnimationFrame || window.oCancelAnimationFrame || function (id) {\\n    window.clearTimeout(id);\\n  };\\n}();\\n\\nfunction coreMixin(BScroll) {\\n  BScroll.prototype._start = function (e) {\\n    var _eventType = eventType[e.type];\\n    if (_eventType !== TOUCH_EVENT) {\\n      if (e.button !== 0) {\\n        return;\\n      }\\n    }\\n    if (!this.enabled || this.destroyed || this.initiated && this.initiated !== _eventType) {\\n      return;\\n    }\\n    this.initiated = _eventType;\\n\\n    if (this.options.preventDefault && !preventDefaultException(e.target, this.options.preventDefaultException)) {\\n      e.preventDefault();\\n    }\\n\\n    this.moved = false;\\n    this.distX = 0;\\n    this.distY = 0;\\n    this.directionX = 0;\\n    this.directionY = 0;\\n    this.movingDirectionX = 0;\\n    this.movingDirectionY = 0;\\n    this.directionLocked = 0;\\n\\n    this._transitionTime();\\n    this.startTime = getNow();\\n\\n    if (this.options.wheel) {\\n      this.target = e.target;\\n    }\\n\\n    this.stop();\\n\\n    var point = e.touches ? e.touches[0] : e;\\n\\n    this.startX = this.x;\\n    this.startY = this.y;\\n    this.absStartX = this.x;\\n    this.absStartY = this.y;\\n    this.pointX = point.pageX;\\n    this.pointY = point.pageY;\\n\\n    this.trigger('beforeScrollStart');\\n  };\\n\\n  BScroll.prototype._move = function (e) {\\n    if (!this.enabled || this.destroyed || eventType[e.type] !== this.initiated) {\\n      return;\\n    }\\n\\n    if (this.options.preventDefault) {\\n      e.preventDefault();\\n    }\\n\\n    var point = e.touches ? e.touches[0] : e;\\n    var deltaX = point.pageX - this.pointX;\\n    var deltaY = point.pageY - this.pointY;\\n\\n    this.pointX = point.pageX;\\n    this.pointY = point.pageY;\\n\\n    this.distX += deltaX;\\n    this.distY += deltaY;\\n\\n    var absDistX = Math.abs(this.distX);\\n    var absDistY = Math.abs(this.distY);\\n\\n    var timestamp = getNow();\\n\\n    // We need to move at least momentumLimitDistance pixels for the scrolling to initiate\\n    if (timestamp - this.endTime > this.options.momentumLimitTime && absDistY < this.options.momentumLimitDistance && absDistX < this.options.momentumLimitDistance) {\\n      return;\\n    }\\n\\n    // If you are scrolling in one direction lock the other\\n    if (!this.directionLocked && !this.options.freeScroll) {\\n      if (absDistX > absDistY + this.options.directionLockThreshold) {\\n        this.directionLocked = 'h'; // lock horizontally\\n      } else if (absDistY >= absDistX + this.options.directionLockThreshold) {\\n        this.directionLocked = 'v'; // lock vertically\\n      } else {\\n        this.directionLocked = 'n'; // no lock\\n      }\\n    }\\n\\n    if (this.directionLocked === 'h') {\\n      if (this.options.eventPassthrough === 'vertical') {\\n        e.preventDefault();\\n      } else if (this.options.eventPassthrough === 'horizontal') {\\n        this.initiated = false;\\n        return;\\n      }\\n      deltaY = 0;\\n    } else if (this.directionLocked === 'v') {\\n      if (this.options.eventPassthrough === 'horizontal') {\\n        e.preventDefault();\\n      } else if (this.options.eventPassthrough === 'vertical') {\\n        this.initiated = false;\\n        return;\\n      }\\n      deltaX = 0;\\n    }\\n\\n    deltaX = this.hasHorizontalScroll ? deltaX : 0;\\n    deltaY = this.hasVerticalScroll ? deltaY : 0;\\n    this.movingDirectionX = deltaX > 0 ? -1 : deltaX < 0 ? 1 : 0;\\n    this.movingDirectionY = deltaY > 0 ? -1 : deltaY < 0 ? 1 : 0;\\n\\n    var newX = this.x + deltaX;\\n    var newY = this.y + deltaY;\\n\\n    // Slow down or stop if outside of the boundaries\\n    if (newX > 0 || newX < this.maxScrollX) {\\n      if (this.options.bounce) {\\n        newX = this.x + deltaX / 3;\\n      } else {\\n        newX = newX > 0 ? 0 : this.maxScrollX;\\n      }\\n    }\\n    if (newY > 0 || newY < this.maxScrollY) {\\n      if (this.options.bounce) {\\n        newY = this.y + deltaY / 3;\\n      } else {\\n        newY = newY > 0 ? 0 : this.maxScrollY;\\n      }\\n    }\\n\\n    if (!this.moved) {\\n      this.moved = true;\\n      this.trigger('scrollStart');\\n    }\\n\\n    this._translate(newX, newY);\\n\\n    if (timestamp - this.startTime > this.options.momentumLimitTime) {\\n      this.startTime = timestamp;\\n      this.startX = this.x;\\n      this.startY = this.y;\\n\\n      if (this.options.probeType === 1) {\\n        this.trigger('scroll', {\\n          x: this.x,\\n          y: this.y\\n        });\\n      }\\n    }\\n\\n    if (this.options.probeType > 1) {\\n      this.trigger('scroll', {\\n        x: this.x,\\n        y: this.y\\n      });\\n    }\\n\\n    var scrollLeft = document.documentElement.scrollLeft || window.pageXOffset || document.body.scrollLeft;\\n    var scrollTop = document.documentElement.scrollTop || window.pageYOffset || document.body.scrollTop;\\n\\n    var pX = this.pointX - scrollLeft;\\n    var pY = this.pointY - scrollTop;\\n\\n    if (pX > document.documentElement.clientWidth - this.options.momentumLimitDistance || pX < this.options.momentumLimitDistance || pY < this.options.momentumLimitDistance || pY > document.documentElement.clientHeight - this.options.momentumLimitDistance) {\\n      this._end(e);\\n    }\\n  };\\n\\n  BScroll.prototype._end = function (e) {\\n    if (!this.enabled || this.destroyed || eventType[e.type] !== this.initiated) {\\n      return;\\n    }\\n    this.initiated = false;\\n\\n    if (this.options.preventDefault && !preventDefaultException(e.target, this.options.preventDefaultException)) {\\n      e.preventDefault();\\n    }\\n\\n    this.trigger('touchEnd', {\\n      x: this.x,\\n      y: this.y\\n    });\\n\\n    // if configure pull down refresh, check it first\\n    if (this.options.pullDownRefresh && this._checkPullDown()) {\\n      return;\\n    }\\n\\n    // reset if we are outside of the boundaries\\n    if (this.resetPosition(this.options.bounceTime, ease.bounce)) {\\n      return;\\n    }\\n    this.isInTransition = false;\\n    // ensures that the last position is rounded\\n    var newX = Math.round(this.x);\\n    var newY = Math.round(this.y);\\n\\n    // we scrolled less than 15 pixels\\n    if (!this.moved) {\\n      if (this.options.wheel) {\\n        if (this.target && this.target.className === 'wheel-scroll') {\\n          var index = Math.abs(Math.round(newY / this.itemHeight));\\n          var _offset = Math.round((this.pointY + offset(this.target).top - this.itemHeight / 2) / this.itemHeight);\\n          this.target = this.items[index + _offset];\\n        }\\n        this.scrollToElement(this.target, this.options.wheel.adjustTime || 400, true, true, ease.swipe);\\n      } else {\\n        if (this.options.tap) {\\n          tap(e, this.options.tap);\\n        }\\n\\n        if (this.options.click) {\\n          click(e);\\n        }\\n      }\\n      this.trigger('scrollCancel');\\n      return;\\n    }\\n\\n    this.scrollTo(newX, newY);\\n\\n    var deltaX = newX - this.absStartX;\\n    var deltaY = newY - this.absStartY;\\n    this.directionX = deltaX > 0 ? -1 : deltaX < 0 ? 1 : 0;\\n    this.directionY = deltaY > 0 ? -1 : deltaY < 0 ? 1 : 0;\\n\\n    this.endTime = getNow();\\n\\n    var duration = this.endTime - this.startTime;\\n    var absDistX = Math.abs(newX - this.startX);\\n    var absDistY = Math.abs(newY - this.startY);\\n\\n    // flick\\n    if (this._events.flick && duration < this.options.flickLimitTime && absDistX < this.options.flickLimitDistance && absDistY < this.options.flickLimitDistance) {\\n      this.trigger('flick');\\n      return;\\n    }\\n\\n    var time = 0;\\n    // start momentum animation if needed\\n    if (this.options.momentum && duration < this.options.momentumLimitTime && (absDistY > this.options.momentumLimitDistance || absDistX > this.options.momentumLimitDistance)) {\\n      var momentumX = this.hasHorizontalScroll ? momentum(this.x, this.startX, duration, this.maxScrollX, this.options.bounce ? this.wrapperWidth : 0, this.options) : { destination: newX, duration: 0 };\\n      var momentumY = this.hasVerticalScroll ? momentum(this.y, this.startY, duration, this.maxScrollY, this.options.bounce ? this.wrapperHeight : 0, this.options) : { destination: newY, duration: 0 };\\n      newX = momentumX.destination;\\n      newY = momentumY.destination;\\n      time = Math.max(momentumX.duration, momentumY.duration);\\n      this.isInTransition = 1;\\n    } else {\\n      if (this.options.wheel) {\\n        newY = Math.round(newY / this.itemHeight) * this.itemHeight;\\n        time = this.options.wheel.adjustTime || 400;\\n      }\\n    }\\n\\n    var easing = ease.swipe;\\n    if (this.options.snap) {\\n      var snap = this._nearestSnap(newX, newY);\\n      this.currentPage = snap;\\n      time = this.options.snapSpeed || Math.max(Math.max(Math.min(Math.abs(newX - snap.x), 1000), Math.min(Math.abs(newY - snap.y), 1000)), 300);\\n      newX = snap.x;\\n      newY = snap.y;\\n\\n      this.directionX = 0;\\n      this.directionY = 0;\\n      easing = ease.bounce;\\n    }\\n\\n    if (newX !== this.x || newY !== this.y) {\\n      // change easing function when scroller goes out of the boundaries\\n      if (newX > 0 || newX < this.maxScrollX || newY > 0 || newY < this.maxScrollY) {\\n        easing = ease.swipeBounce;\\n      }\\n      this.scrollTo(newX, newY, time, easing);\\n      return;\\n    }\\n\\n    if (this.options.wheel) {\\n      this.selectedIndex = Math.abs(this.y / this.itemHeight) | 0;\\n    }\\n    this.trigger('scrollEnd', {\\n      x: this.x,\\n      y: this.y\\n    });\\n  };\\n\\n  BScroll.prototype._resize = function () {\\n    var _this = this;\\n\\n    if (!this.enabled) {\\n      return;\\n    }\\n\\n    clearTimeout(this.resizeTimeout);\\n    this.resizeTimeout = setTimeout(function () {\\n      _this.refresh();\\n    }, this.options.resizePolling);\\n  };\\n\\n  BScroll.prototype._startProbe = function () {\\n    cancelAnimationFrame(this.probeTimer);\\n    this.probeTimer = requestAnimationFrame(probe);\\n\\n    var me = this;\\n\\n    function probe() {\\n      if (!me.isInTransition) {\\n        return;\\n      }\\n      var pos = me.getComputedPosition();\\n      me.trigger('scroll', pos);\\n      me.probeTimer = requestAnimationFrame(probe);\\n    }\\n  };\\n\\n  BScroll.prototype._transitionTime = function () {\\n    var time = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\\n\\n    this.scrollerStyle[style.transitionDuration] = time + 'ms';\\n\\n    if (this.options.wheel) {\\n      for (var i = 0; i < this.items.length; i++) {\\n        this.items[i].style[style.transitionDuration] = time + 'ms';\\n      }\\n    }\\n\\n    if (this.indicators) {\\n      for (var _i = 0; _i < this.indicators.length; _i++) {\\n        this.indicators[_i].transitionTime(time);\\n      }\\n    }\\n  };\\n\\n  BScroll.prototype._transitionTimingFunction = function (easing) {\\n    this.scrollerStyle[style.transitionTimingFunction] = easing;\\n\\n    if (this.options.wheel) {\\n      for (var i = 0; i < this.items.length; i++) {\\n        this.items[i].style[style.transitionTimingFunction] = easing;\\n      }\\n    }\\n\\n    if (this.indicators) {\\n      for (var _i2 = 0; _i2 < this.indicators.length; _i2++) {\\n        this.indicators[_i2].transitionTimingFunction(easing);\\n      }\\n    }\\n  };\\n\\n  BScroll.prototype._transitionEnd = function (e) {\\n    if (e.target !== this.scroller || !this.isInTransition) {\\n      return;\\n    }\\n\\n    this._transitionTime();\\n    if (!this.pulling && !this.resetPosition(this.options.bounceTime, ease.bounce)) {\\n      this.isInTransition = false;\\n      this.trigger('scrollEnd', {\\n        x: this.x,\\n        y: this.y\\n      });\\n    }\\n  };\\n\\n  BScroll.prototype._translate = function (x, y) {\\n    if (this.options.useTransform) {\\n      this.scrollerStyle[style.transform] = 'translate(' + x + 'px,' + y + 'px)' + this.translateZ;\\n    } else {\\n      x = Math.round(x);\\n      y = Math.round(y);\\n      this.scrollerStyle.left = x + 'px';\\n      this.scrollerStyle.top = y + 'px';\\n    }\\n\\n    if (this.options.wheel) {\\n      var _options$wheel$rotate = this.options.wheel.rotate,\\n          rotate = _options$wheel$rotate === undefined ? 25 : _options$wheel$rotate;\\n\\n      for (var i = 0; i < this.items.length; i++) {\\n        var deg = rotate * (y / this.itemHeight + i);\\n        this.items[i].style[style.transform] = 'rotateX(' + deg + 'deg)';\\n      }\\n    }\\n\\n    this.x = x;\\n    this.y = y;\\n\\n    if (this.indicators) {\\n      for (var _i3 = 0; _i3 < this.indicators.length; _i3++) {\\n        this.indicators[_i3].updatePosition();\\n      }\\n    }\\n  };\\n\\n  BScroll.prototype._animate = function (destX, destY, duration, easingFn) {\\n    var me = this;\\n    var startX = this.x;\\n    var startY = this.y;\\n    var startTime = getNow();\\n    var destTime = startTime + duration;\\n\\n    function step() {\\n      var now = getNow();\\n\\n      if (now >= destTime) {\\n        me.isAnimating = false;\\n        me._translate(destX, destY);\\n\\n        if (!me.pulling && !me.resetPosition(me.options.bounceTime)) {\\n          me.trigger('scrollEnd', {\\n            x: me.x,\\n            y: me.y\\n          });\\n        }\\n        return;\\n      }\\n      now = (now - startTime) / duration;\\n      var easing = easingFn(now);\\n      var newX = (destX - startX) * easing + startX;\\n      var newY = (destY - startY) * easing + startY;\\n\\n      me._translate(newX, newY);\\n\\n      if (me.isAnimating) {\\n        me.animateTimer = requestAnimationFrame(step);\\n      }\\n\\n      if (me.options.probeType === 3) {\\n        me.trigger('scroll', {\\n          x: this.x,\\n          y: this.y\\n        });\\n      }\\n    }\\n\\n    this.isAnimating = true;\\n    cancelAnimationFrame(this.animateTimer);\\n    step();\\n  };\\n\\n  BScroll.prototype.scrollBy = function (x, y) {\\n    var time = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\\n    var easing = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : ease.bounce;\\n\\n    x = this.x + x;\\n    y = this.y + y;\\n\\n    this.scrollTo(x, y, time, easing);\\n  };\\n\\n  BScroll.prototype.scrollTo = function (x, y) {\\n    var time = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\\n    var easing = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : ease.bounce;\\n\\n    this.isInTransition = this.options.useTransition && time > 0 && (x !== this.x || y !== this.y);\\n\\n    if (!time || this.options.useTransition) {\\n      this._transitionTimingFunction(easing.style);\\n      this._transitionTime(time);\\n      this._translate(x, y);\\n\\n      if (time && this.options.probeType === 3) {\\n        this._startProbe();\\n      }\\n\\n      if (this.options.wheel) {\\n        if (y > 0) {\\n          this.selectedIndex = 0;\\n        } else if (y < this.maxScrollY) {\\n          this.selectedIndex = this.items.length - 1;\\n        } else {\\n          this.selectedIndex = Math.abs(y / this.itemHeight) | 0;\\n        }\\n      }\\n    } else {\\n      this._animate(x, y, time, easing.fn);\\n    }\\n  };\\n\\n  BScroll.prototype.scrollToElement = function (el, time, offsetX, offsetY, easing) {\\n    if (!el) {\\n      return;\\n    }\\n    el = el.nodeType ? el : this.scroller.querySelector(el);\\n\\n    if (this.options.wheel && el.className !== 'wheel-item') {\\n      return;\\n    }\\n\\n    var pos = offset(el);\\n    pos.left -= this.wrapperOffset.left;\\n    pos.top -= this.wrapperOffset.top;\\n\\n    // if offsetX/Y are true we center the element to the screen\\n    if (offsetX === true) {\\n      offsetX = Math.round(el.offsetWidth / 2 - this.wrapper.offsetWidth / 2);\\n    }\\n    if (offsetY === true) {\\n      offsetY = Math.round(el.offsetHeight / 2 - this.wrapper.offsetHeight / 2);\\n    }\\n\\n    pos.left -= offsetX || 0;\\n    pos.top -= offsetY || 0;\\n    pos.left = pos.left > 0 ? 0 : pos.left < this.maxScrollX ? this.maxScrollX : pos.left;\\n    pos.top = pos.top > 0 ? 0 : pos.top < this.maxScrollY ? this.maxScrollY : pos.top;\\n\\n    if (this.options.wheel) {\\n      pos.top = Math.round(pos.top / this.itemHeight) * this.itemHeight;\\n    }\\n\\n    this.scrollTo(pos.left, pos.top, time, easing);\\n  };\\n\\n  BScroll.prototype.resetPosition = function () {\\n    var time = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\\n    var easeing = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : ease.bounce;\\n\\n    var x = this.x;\\n    if (!this.hasHorizontalScroll || x > 0) {\\n      x = 0;\\n    } else if (x < this.maxScrollX) {\\n      x = this.maxScrollX;\\n    }\\n\\n    var y = this.y;\\n    if (!this.hasVerticalScroll || y > 0) {\\n      y = 0;\\n    } else if (y < this.maxScrollY) {\\n      y = this.maxScrollY;\\n    }\\n\\n    if (x === this.x && y === this.y) {\\n      return false;\\n    }\\n\\n    this.scrollTo(x, y, time, easeing);\\n\\n    return true;\\n  };\\n\\n  BScroll.prototype.getComputedPosition = function () {\\n    var matrix = window.getComputedStyle(this.scroller, null);\\n    var x = void 0;\\n    var y = void 0;\\n\\n    if (this.options.useTransform) {\\n      matrix = matrix[style.transform].split(')')[0].split(', ');\\n      x = +(matrix[12] || matrix[4]);\\n      y = +(matrix[13] || matrix[5]);\\n    } else {\\n      x = +matrix.left.replace(/[^-\\\\d.]/g, '');\\n      y = +matrix.top.replace(/[^-\\\\d.]/g, '');\\n    }\\n\\n    return {\\n      x: x,\\n      y: y\\n    };\\n  };\\n\\n  BScroll.prototype.stop = function () {\\n    if (this.options.useTransition && this.isInTransition) {\\n      this.isInTransition = false;\\n      var pos = this.getComputedPosition();\\n      this._translate(pos.x, pos.y);\\n      if (this.options.wheel) {\\n        this.target = this.items[Math.round(-pos.y / this.itemHeight)];\\n      } else {\\n        this.trigger('scrollEnd', {\\n          x: this.x,\\n          y: this.y\\n        });\\n      }\\n    } else if (!this.options.useTransition && this.isAnimating) {\\n      this.isAnimating = false;\\n      this.trigger('scrollEnd', {\\n        x: this.x,\\n        y: this.y\\n      });\\n    }\\n  };\\n\\n  BScroll.prototype.destroy = function () {\\n    this._removeDOMEvents();\\n    // remove custom events\\n    this._events = {};\\n\\n    if (this.options.scrollbar) {\\n      this._removeScrollBars();\\n    }\\n\\n    this.destroyed = true;\\n    this.trigger('destroy');\\n  };\\n}\\n\\nfunction snapMixin(BScroll) {\\n  BScroll.prototype._initSnap = function () {\\n    var _this = this;\\n\\n    this.currentPage = {};\\n    var snap = this.options.snap;\\n\\n    if (snap.loop) {\\n      var children = this.scroller.children;\\n      if (children.length > 0) {\\n        prepend(children[children.length - 1].cloneNode(true), this.scroller);\\n        this.scroller.appendChild(children[1].cloneNode(true));\\n      }\\n    }\\n\\n    var el = snap.el;\\n    if (typeof el === 'string') {\\n      el = this.scroller.querySelectorAll(el);\\n    }\\n\\n    this.on('refresh', function () {\\n      _this.pages = [];\\n\\n      if (!_this.wrapperWidth || !_this.wrapperHeight || !_this.scrollerWidth || !_this.scrollerHeight) {\\n        return;\\n      }\\n\\n      var stepX = snap.stepX || _this.wrapperWidth;\\n      var stepY = snap.stepY || _this.wrapperHeight;\\n\\n      var x = 0;\\n      var y = void 0;\\n      var cx = void 0;\\n      var cy = void 0;\\n      var i = 0;\\n      var l = void 0;\\n      var m = 0;\\n      var n = void 0;\\n      var rect = void 0;\\n      if (!el) {\\n        cx = Math.round(stepX / 2);\\n        cy = Math.round(stepY / 2);\\n\\n        while (x > -_this.scrollerWidth) {\\n          _this.pages[i] = [];\\n          l = 0;\\n          y = 0;\\n\\n          while (y > -_this.scrollerHeight) {\\n            _this.pages[i][l] = {\\n              x: Math.max(x, _this.maxScrollX),\\n              y: Math.max(y, _this.maxScrollY),\\n              width: stepX,\\n              height: stepY,\\n              cx: x - cx,\\n              cy: y - cy\\n            };\\n\\n            y -= stepY;\\n            l++;\\n          }\\n\\n          x -= stepX;\\n          i++;\\n        }\\n      } else {\\n        l = el.length;\\n        n = -1;\\n\\n        for (; i < l; i++) {\\n          rect = getRect(el[i]);\\n          if (i === 0 || rect.left <= getRect(el[i - 1]).left) {\\n            m = 0;\\n            n++;\\n          }\\n\\n          if (!_this.pages[m]) {\\n            _this.pages[m] = [];\\n          }\\n\\n          x = Math.max(-rect.left, _this.maxScrollX);\\n          y = Math.max(-rect.top, _this.maxScrollY);\\n          cx = x - Math.round(rect.width / 2);\\n          cy = y - Math.round(rect.height / 2);\\n\\n          _this.pages[m][n] = {\\n            x: x,\\n            y: y,\\n            width: rect.width,\\n            height: rect.height,\\n            cx: cx,\\n            cy: cy\\n          };\\n\\n          if (x > _this.maxScrollX) {\\n            m++;\\n          }\\n        }\\n      }\\n\\n      var initPage = snap.loop ? 1 : 0;\\n      _this.goToPage(_this.currentPage.pageX || initPage, _this.currentPage.pageY || 0, 0);\\n\\n      // Update snap threshold if needed\\n      var snapThreshold = snap.threshold;\\n      if (snapThreshold % 1 === 0) {\\n        _this.snapThresholdX = snapThreshold;\\n        _this.snapThresholdY = snapThreshold;\\n      } else {\\n        _this.snapThresholdX = Math.round(_this.pages[_this.currentPage.pageX][_this.currentPage.pageY].width * snapThreshold);\\n        _this.snapThresholdY = Math.round(_this.pages[_this.currentPage.pageX][_this.currentPage.pageY].height * snapThreshold);\\n      }\\n    });\\n\\n    this.on('scrollEnd', function () {\\n      if (snap.loop) {\\n        if (_this.currentPage.pageX === 0) {\\n          _this.goToPage(_this.pages.length - 2, _this.currentPage.pageY, 0);\\n        }\\n        if (_this.currentPage.pageX === _this.pages.length - 1) {\\n          _this.goToPage(1, _this.currentPage.pageY, 0);\\n        }\\n      }\\n    });\\n\\n    if (snap.listenFlick !== false) {\\n      this.on('flick', function () {\\n        var time = snap.speed || Math.max(Math.max(Math.min(Math.abs(_this.x - _this.startX), 1000), Math.min(Math.abs(_this.y - _this.startY), 1000)), 300);\\n\\n        _this.goToPage(_this.currentPage.pageX + _this.directionX, _this.currentPage.pageY + _this.directionY, time);\\n      });\\n    }\\n  };\\n\\n  BScroll.prototype._nearestSnap = function (x, y) {\\n    if (!this.pages.length) {\\n      return { x: 0, y: 0, pageX: 0, pageY: 0 };\\n    }\\n\\n    var i = 0;\\n    // Check if we exceeded the snap threshold\\n    if (Math.abs(x - this.absStartX) <= this.snapThresholdX && Math.abs(y - this.absStartY) <= this.snapThresholdY) {\\n      return this.currentPage;\\n    }\\n\\n    if (x > 0) {\\n      x = 0;\\n    } else if (x < this.maxScrollX) {\\n      x = this.maxScrollX;\\n    }\\n\\n    if (y > 0) {\\n      y = 0;\\n    } else if (y < this.maxScrollY) {\\n      y = this.maxScrollY;\\n    }\\n\\n    var l = this.pages.length;\\n    for (; i < l; i++) {\\n      if (x >= this.pages[i][0].cx) {\\n        x = this.pages[i][0].x;\\n        break;\\n      }\\n    }\\n\\n    l = this.pages[i].length;\\n\\n    var m = 0;\\n    for (; m < l; m++) {\\n      if (y >= this.pages[0][m].cy) {\\n        y = this.pages[0][m].y;\\n        break;\\n      }\\n    }\\n\\n    if (i === this.currentPage.pageX) {\\n      i += this.directionX;\\n\\n      if (i < 0) {\\n        i = 0;\\n      } else if (i >= this.pages.length) {\\n        i = this.pages.length - 1;\\n      }\\n\\n      x = this.pages[i][0].x;\\n    }\\n\\n    if (m === this.currentPage.pageY) {\\n      m += this.directionY;\\n\\n      if (m < 0) {\\n        m = 0;\\n      } else if (m >= this.pages[0].length) {\\n        m = this.pages[0].length - 1;\\n      }\\n\\n      y = this.pages[0][m].y;\\n    }\\n\\n    return {\\n      x: x,\\n      y: y,\\n      pageX: i,\\n      pageY: m\\n    };\\n  };\\n\\n  BScroll.prototype.goToPage = function (x, y, time) {\\n    var easing = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : ease.bounce;\\n\\n    var snap = this.options.snap;\\n    if (x >= this.pages.length) {\\n      x = this.pages.length - 1;\\n    } else if (x < 0) {\\n      x = 0;\\n    }\\n\\n    if (y >= this.pages[x].length) {\\n      y = this.pages[x].length - 1;\\n    } else if (y < 0) {\\n      y = 0;\\n    }\\n\\n    var posX = this.pages[x][y].x;\\n    var posY = this.pages[x][y].y;\\n\\n    time = time === undefined ? snap.speed || Math.max(Math.max(Math.min(Math.abs(posX - this.x), 1000), Math.min(Math.abs(posY - this.y), 1000)), 300) : time;\\n\\n    this.currentPage = {\\n      x: posX,\\n      y: posY,\\n      pageX: x,\\n      pageY: y\\n    };\\n    this.scrollTo(posX, posY, time, easing);\\n  };\\n\\n  BScroll.prototype.next = function (time, easing) {\\n    var x = this.currentPage.pageX;\\n    var y = this.currentPage.pageY;\\n\\n    x++;\\n    if (x >= this.pages.length && this.hasVerticalScroll) {\\n      x = 0;\\n      y++;\\n    }\\n\\n    this.goToPage(x, y, time, easing);\\n  };\\n\\n  BScroll.prototype.prev = function (time, easing) {\\n    var x = this.currentPage.pageX;\\n    var y = this.currentPage.pageY;\\n\\n    x--;\\n    if (x < 0 && this.hasVerticalScroll) {\\n      x = 0;\\n      y--;\\n    }\\n\\n    this.goToPage(x, y, time, easing);\\n  };\\n\\n  BScroll.prototype.getCurrentPage = function () {\\n    return this.options.snap && this.currentPage;\\n  };\\n}\\n\\nfunction wheelMixin(BScroll) {\\n  BScroll.prototype.wheelTo = function (index) {\\n    if (this.options.wheel) {\\n      this.y = -index * this.itemHeight;\\n      this.scrollTo(0, this.y);\\n    }\\n  };\\n\\n  BScroll.prototype.getSelectedIndex = function () {\\n    return this.options.wheel && this.selectedIndex;\\n  };\\n}\\n\\nvar INDICATOR_MIN_LEN = 8;\\n\\nfunction scrollbarMixin(BScroll) {\\n  BScroll.prototype._initScrollbar = function () {\\n    var _this = this;\\n\\n    var _options$scrollbar$fa = this.options.scrollbar.fade,\\n        fade = _options$scrollbar$fa === undefined ? true : _options$scrollbar$fa;\\n\\n    this.indicators = [];\\n    var indicator = void 0;\\n\\n    if (this.options.scrollX) {\\n      indicator = {\\n        el: createScrollbar('horizontal'),\\n        direction: 'horizontal',\\n        fade: fade\\n      };\\n      this._insertScrollBar(indicator.el);\\n\\n      this.indicators.push(new Indicator(this, indicator));\\n    }\\n\\n    if (this.options.scrollY) {\\n      indicator = {\\n        el: createScrollbar('vertical'),\\n        direction: 'vertical',\\n        fade: fade\\n      };\\n      this._insertScrollBar(indicator.el);\\n      this.indicators.push(new Indicator(this, indicator));\\n    }\\n\\n    this.on('refresh', function () {\\n      for (var i = 0; i < _this.indicators.length; i++) {\\n        _this.indicators[i].refresh();\\n      }\\n    });\\n\\n    if (fade) {\\n      this.on('scrollEnd', function () {\\n        for (var i = 0; i < _this.indicators.length; i++) {\\n          _this.indicators[i].fade();\\n        }\\n      });\\n\\n      this.on('scrollCancel', function () {\\n        for (var i = 0; i < _this.indicators.length; i++) {\\n          _this.indicators[i].fade();\\n        }\\n      });\\n\\n      this.on('scrollStart', function () {\\n        for (var i = 0; i < _this.indicators.length; i++) {\\n          _this.indicators[i].fade(true);\\n        }\\n      });\\n\\n      this.on('beforeScrollStart', function () {\\n        for (var i = 0; i < _this.indicators.length; i++) {\\n          _this.indicators[i].fade(true, true);\\n        }\\n      });\\n    }\\n  };\\n\\n  BScroll.prototype._insertScrollBar = function (scrollbar) {\\n    this.wrapper.appendChild(scrollbar);\\n  };\\n\\n  BScroll.prototype._removeScrollBars = function () {\\n    for (var i = 0; i < this.indicators.length; i++) {\\n      var indicator = this.indicators[i];\\n      indicator.remove();\\n    }\\n  };\\n}\\n\\nfunction createScrollbar(direction) {\\n  var scrollbar = document.createElement('div');\\n  var indicator = document.createElement('div');\\n\\n  scrollbar.style.cssText = 'position:absolute;z-index:9999;pointerEvents:none';\\n  indicator.style.cssText = 'box-sizing:border-box;position:absolute;background:rgba(0,0,0,0.5);border:1px solid rgba(255,255,255,0.9);border-radius:3px;';\\n\\n  indicator.className = 'bscroll-indicator';\\n\\n  if (direction === 'horizontal') {\\n    scrollbar.style.cssText += ';height:7px;left:2px;right:2px;bottom:0';\\n    indicator.style.height = '100%';\\n    scrollbar.className = 'bscroll-horizontal-scrollbar';\\n  } else {\\n    scrollbar.style.cssText += ';width:7px;bottom:2px;top:2px;right:1px';\\n    indicator.style.width = '100%';\\n    scrollbar.className = 'bscroll-vertical-scrollbar';\\n  }\\n\\n  scrollbar.style.cssText += ';overflow:hidden';\\n  scrollbar.appendChild(indicator);\\n\\n  return scrollbar;\\n}\\n\\nfunction Indicator(scroller, options) {\\n  this.wrapper = options.el;\\n  this.wrapperStyle = this.wrapper.style;\\n  this.indicator = this.wrapper.children[0];\\n  this.indicatorStyle = this.indicator.style;\\n  this.scroller = scroller;\\n  this.direction = options.direction;\\n  if (options.fade) {\\n    this.visible = 0;\\n    this.wrapperStyle.opacity = '0';\\n  } else {\\n    this.visible = 1;\\n  }\\n}\\n\\nIndicator.prototype.refresh = function () {\\n  this.transitionTime();\\n  this._calculate();\\n  this.updatePosition();\\n};\\n\\nIndicator.prototype.fade = function (visible, hold) {\\n  var _this2 = this;\\n\\n  if (hold && !this.visible) {\\n    return;\\n  }\\n\\n  var time = visible ? 250 : 500;\\n\\n  visible = visible ? '1' : '0';\\n\\n  this.wrapperStyle[style.transitionDuration] = time + 'ms';\\n\\n  clearTimeout(this.fadeTimeout);\\n  this.fadeTimeout = setTimeout(function () {\\n    _this2.wrapperStyle.opacity = visible;\\n    _this2.visible = +visible;\\n  }, 0);\\n};\\n\\nIndicator.prototype.updatePosition = function () {\\n  if (this.direction === 'vertical') {\\n    var y = Math.round(this.sizeRatioY * this.scroller.y);\\n\\n    if (y < 0) {\\n      this.transitionTime(500);\\n      var height = Math.max(this.indicatorHeight + y * 3, INDICATOR_MIN_LEN);\\n      this.indicatorStyle.height = height + 'px';\\n      y = 0;\\n    } else if (y > this.maxPosY) {\\n      this.transitionTime(500);\\n      var _height = Math.max(this.indicatorHeight - (y - this.maxPosY) * 3, INDICATOR_MIN_LEN);\\n      this.indicatorStyle.height = _height + 'px';\\n      y = this.maxPosY + this.indicatorHeight - _height;\\n    } else {\\n      this.indicatorStyle.height = this.indicatorHeight + 'px';\\n    }\\n    this.y = y;\\n\\n    if (this.scroller.options.useTransform) {\\n      this.indicatorStyle[style.transform] = 'translateY(' + y + 'px)' + this.scroller.translateZ;\\n    } else {\\n      this.indicatorStyle.top = y + 'px';\\n    }\\n  } else {\\n    var x = Math.round(this.sizeRatioX * this.scroller.x);\\n\\n    if (x < 0) {\\n      this.transitionTime(500);\\n      var width = Math.max(this.indicatorWidth + x * 3, INDICATOR_MIN_LEN);\\n      this.indicatorStyle.width = width + 'px';\\n      x = 0;\\n    } else if (x > this.maxPosX) {\\n      this.transitionTime(500);\\n      var _width = Math.max(this.indicatorWidth - (x - this.maxPosX) * 3, INDICATOR_MIN_LEN);\\n      this.indicatorStyle.width = _width + 'px';\\n      x = this.maxPosX + this.indicatorWidth - _width;\\n    } else {\\n      this.indicatorStyle.width = this.indicatorWidth + 'px';\\n    }\\n\\n    this.x = x;\\n\\n    if (this.scroller.options.useTransform) {\\n      this.indicatorStyle[style.transform] = 'translateX(' + x + 'px)' + this.scroller.translateZ;\\n    } else {\\n      this.indicatorStyle.left = x + 'px';\\n    }\\n  }\\n};\\n\\nIndicator.prototype.transitionTime = function () {\\n  var time = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\\n\\n  this.indicatorStyle[style.transitionDuration] = time + 'ms';\\n};\\n\\nIndicator.prototype.transitionTimingFunction = function (easing) {\\n  this.indicatorStyle[style.transitionTimingFunction] = easing;\\n};\\n\\nIndicator.prototype.remove = function () {\\n  this.wrapper.parentNode.removeChild(this.wrapper);\\n};\\n\\nIndicator.prototype._calculate = function () {\\n  if (this.direction === 'vertical') {\\n    var wrapperHeight = this.wrapper.clientHeight;\\n    this.indicatorHeight = Math.max(Math.round(wrapperHeight * wrapperHeight / (this.scroller.scrollerHeight || wrapperHeight || 1)), INDICATOR_MIN_LEN);\\n    this.indicatorStyle.height = this.indicatorHeight + 'px';\\n\\n    this.maxPosY = wrapperHeight - this.indicatorHeight;\\n\\n    this.sizeRatioY = this.maxPosY / this.scroller.maxScrollY;\\n  } else {\\n    var wrapperWidth = this.wrapper.clientWidth;\\n    this.indicatorWidth = Math.max(Math.round(wrapperWidth * wrapperWidth / (this.scroller.scrollerWidth || wrapperWidth || 1)), INDICATOR_MIN_LEN);\\n    this.indicatorStyle.width = this.indicatorWidth + 'px';\\n\\n    this.maxPosX = wrapperWidth - this.indicatorWidth;\\n\\n    this.sizeRatioX = this.maxPosX / this.scroller.maxScrollX;\\n  }\\n};\\n\\nfunction pullDownMixin(BScroll) {\\n  BScroll.prototype._initPullDown = function () {\\n    // must watch scroll in real time\\n    this.options.probeType = 3;\\n  };\\n\\n  BScroll.prototype._checkPullDown = function () {\\n    var _options$pullDownRefr = this.options.pullDownRefresh,\\n        _options$pullDownRefr2 = _options$pullDownRefr.threshold,\\n        threshold = _options$pullDownRefr2 === undefined ? 90 : _options$pullDownRefr2,\\n        _options$pullDownRefr3 = _options$pullDownRefr.stop,\\n        stop = _options$pullDownRefr3 === undefined ? 40 : _options$pullDownRefr3;\\n\\n    if (this.y > threshold && !this.pulling) {\\n      this.pulling = true;\\n      this.trigger('pullingDown');\\n      this.scrollTo(this.x, stop, this.options.bounceTime, ease.bounce);\\n    }\\n\\n    return this.pulling;\\n  };\\n\\n  BScroll.prototype.finishPullDown = function () {\\n    this.pulling = false;\\n    this.resetPosition(this.options.bounceTime, ease.bounce);\\n  };\\n}\\n\\nfunction pullUpMixin(BScroll) {\\n  BScroll.prototype._initPullUp = function () {\\n    // must watch scroll in real time\\n    this.options.probeType = 3;\\n\\n    this.pullupWatching = false;\\n    this._watchPullUp();\\n  };\\n\\n  BScroll.prototype._watchPullUp = function () {\\n    if (this.pullupWatching) {\\n      return;\\n    }\\n    this.pullupWatching = true;\\n    var _options$pullUpLoad$t = this.options.pullUpLoad.threshold,\\n        threshold = _options$pullUpLoad$t === undefined ? 0 : _options$pullUpLoad$t;\\n\\n\\n    this.on('scroll', checkToEnd);\\n\\n    function checkToEnd(pos) {\\n      if (this.movingDirectionY === 1 && pos.y <= this.maxScrollY + threshold) {\\n        this.trigger('pullingUp');\\n        this.pullupWatching = false;\\n        this.off('scroll', checkToEnd);\\n      }\\n    }\\n  };\\n\\n  BScroll.prototype.finishPullUp = function () {\\n    var _this = this;\\n\\n    if (this.isInTransition) {\\n      this.once('scrollEnd', function () {\\n        _this._watchPullUp();\\n      });\\n    } else {\\n      this._watchPullUp();\\n    }\\n  };\\n}\\n\\nfunction warn(msg) {\\n  console.error(\\\"[BScroll warn]: \\\" + msg);\\n}\\n\\nfunction BScroll(el, options) {\\n  this.wrapper = typeof el === 'string' ? document.querySelector(el) : el;\\n  if (!this.wrapper) {\\n    warn('can not resolve the wrapper dom');\\n  }\\n  this.scroller = this.wrapper.children[0];\\n  if (!this.scroller) {\\n    warn('the wrapper need at least one child element to be scroller');\\n  }\\n  // cache style for better performance\\n  this.scrollerStyle = this.scroller.style;\\n\\n  this._init(el, options);\\n}\\n\\ninitMixin(BScroll);\\ncoreMixin(BScroll);\\neventMixin(BScroll);\\nsnapMixin(BScroll);\\nwheelMixin(BScroll);\\nscrollbarMixin(BScroll);\\npullDownMixin(BScroll);\\npullUpMixin(BScroll);\\n\\nBScroll.Version = '1.3.1';\\n\\nreturn BScroll;\\n\\n})));\\n\"\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/raw-loader!./~/better-scroll/dist/bscroll.js\n// module id = 666\n// module chunks = 3","/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\nmodule.exports = function(src) {\n\tfunction log(error) {\n\t\t(typeof console !== \"undefined\")\n\t\t&& (console.error || console.log)(\"[Script Loader]\", error);\n\t}\n\n\t// Check for IE =< 8\n\tfunction isIE() {\n\t\treturn typeof attachEvent !== \"undefined\" && typeof addEventListener === \"undefined\";\n\t}\n\n\ttry {\n\t\tif (typeof execScript !== \"undefined\" && isIE()) {\n\t\t\texecScript(src);\n\t\t} else if (typeof eval !== \"undefined\") {\n\t\t\teval.call(null, src);\n\t\t} else {\n\t\t\tlog(\"EvalError: No eval function available\");\n\t\t}\n\t} catch (error) {\n\t\tlog(error);\n\t}\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/script-loader/addScript.js\n// module id = 701\n// module chunks = 3"],"sourceRoot":""}